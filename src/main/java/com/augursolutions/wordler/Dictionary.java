/**
 * 
 */
package com.augursolutions.wordler;

import java.io.Serializable;
import java.util.Iterator;
import java.util.Random;

/**
 * Abstract dictionary class
 * @author Steven Major
 *
 */
@SuppressWarnings("serial")
public abstract class Dictionary implements Serializable, Iterable<String>, Cloneable{

	private transient Random rand;
	
	/**
	 * Gets the number of words in the dictionary
	 * @return number of words in the dictionary
	 */
	public abstract int getSize();
	
	/**
	 * Add a word to the {@link Dictionary} - should increment size by 1 if word is added
	 * @param word A word to be added to the {@link Dictionary}
	 * @return {@code true} if the word is added ({@code false} if the word already exists or if {@code word} is null or otherwise invalid)
	 */
	public abstract boolean add(String word);

	/**
	 * Add all elements of a set to the dictionary 
	 * @param <T> any class that implements Iterator&lt;String&gt;
	 * @param words Words to add to the dictionary
	 */
	public <T extends Iterable<String>> void addAll(T words) {
		if(words == null)
			return;
		for(String s : words) {
			this.add(s);
		}
	}
	
	/**
	 * Remove a word from the {@link Dictionary}; the {@link Dictionary} object is 
	 * modified in the process. If {@code word} is not present in the dictionary, it should be
	 * left unmodified - should increment size by 1 if word is removed
	 * @param word word to be removed from the {@link Dictionary}
	 */
	public abstract void remove(String word);
	
	/**
	 * Determine if a word is in the dictionary
	 * @param word String to check against the dictionary contents
	 * @return {@code true} if the word is in the dictionary
	 */
	public abstract boolean contains(String word);

	/**
	 * Sets the random seed for the {@link #getRandomWord()} and {@link #getRandomWord(Word[])} methods
	 * @param seed Any {@code int} is valid
	 */
	public void setSeed(int seed) {
		this.rand = new Random(seed);
	}
	
	protected Random getRand() {
		if(this.rand == null) {
			this.rand = new Random();
		}
		return this.rand;
	}
	
	/**
	 * Get a random word from the dictionary - all words are equally likely to be retrieved regardless of size
	 * @return A randomly chosen word from the dictionary
	 */
	public String getRandomWord() {
		Random r = this.getRand();
		int index = r.nextInt(this.getSize());
		Iterator<String> iter = this.iterator();
		String w = iter.next();
		for(int i=0; i<index; i++) {
			w = iter.next();
		}
		return w;
	}
	
	/**
	 * Returns a randomly chosen member of the provided {@code lookupTable} array. Ideally,
	 * this is generated by calling {@link #getRandomWordLookupTable()} first and then passing
	 * the array from that call in to this method with each call. 
	 * @param lookupTable Array of {@link String} objects
	 * @return a randomly chosen member of the provided {@code lookupTable} array
	 */
	public String getRandomWord(String[] lookupTable) {
		Random r = this.getRand();
		int index = r.nextInt(lookupTable.length);
		return lookupTable[index];
	}
	
	/**
	 * Generate an array with every Word in the Dictionary. This is not efficient from a memory
	 * stand-point but allows for fast generation of random words from the dictionary
	 * @return An array with every {@link Word} in the dictionary (in alphabetical order)
	 */
	public String[] getRandomWordLookupTable() {
	  String[] wordTable = new String[this.getSize()];
	  int i=0;
	  for(String w : this) {
		  wordTable[i++] = w;
	  }
	  return wordTable;
	}
	
	public Dictionary clone() {
	    try {
	    	Dictionary d = getClass().getDeclaredConstructor().newInstance();
	    	for(String w : this) {
	    		d.add(w);
	    	}
	        return d;
	    } catch (Exception e) {
	        e.printStackTrace();
	    } 
	    return null;
	}
}
